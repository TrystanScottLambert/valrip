# generated by datamodel-codegen:
#   filename:  waves_maml_schema_v1p0.json
#   timestamp: 2025-12-04T04:42:54+00:00
#   1. Run: datamodel-codegen --input rip_validator/schemas/waves_maml_schema_v1p0.json --input-file-type jsonschema --output rip_validator/model_waves_maml.py.
#   2. Rename the classes to end with "Entry", otherwise there are conflicts with the "Field" class due to that being a reserved word.
#   3. Replace 'const' with 'Literal'.
#   4. Replace 'regex' with 'pattern'.
#   5. Replace Survey and License string types with the relevant enums from .data_types
#   6. Remove the pydantic.Extra import, import pydantic.ConfigDict, and replace the
#      "class Config: extra = Extra.forbid" with "model_config = ConfigDict(extra="forbid")""

from __future__ import annotations

from datetime import date as date_aliased
from typing import List, Optional, Union
from pydantic import BaseModel, ConfigDict, Field, field_validator


from email_validator import EmailNotValidError, validate_email
from .data_types import MAML_VERSION, SurveyName, License

import re


def _is_valid_email(email: str) -> None:
    """
    Raise ValueError if email is invalid (Pydantic-friendly).
    """
    try:
        validate_email(email, check_deliverability=True)
    except EmailNotValidError as e:
        raise ValueError(f"Invalid email address '{email}': {e}")


_EMAIL_RE = re.compile(r"^(?P<name>.+?)\s*<(?P<email>[^>]+)>$")


def _validate_name_email(value: str) -> str:
    match = _EMAIL_RE.match(value)
    if not match:
        raise ValueError("Must be in the format 'Full Name <email@example.com>'.")

    email = match.group("email")
    _is_valid_email(email)

    return value


class DOIEntry(BaseModel):
    model_config = ConfigDict(extra="forbid")
    DOI: str = Field(..., description="Valid DOI")
    type: str = Field(..., description="Type of DOI")


class DependEntry(BaseModel):
    model_config = ConfigDict(extra="forbid")
    survey: str = Field(..., description="The name of the dependent survey.")
    dataset: str = Field(..., description="The name of the dependent dataset.")
    table: str = Field(..., description="The name of the dependent table.")
    version: Union[str, float] = Field(
        ..., description="The version of the dependent table."
    )


class QCEntry(BaseModel):
    model_config = ConfigDict(extra="forbid")
    min: float = Field(..., description="Required data minimum value")
    max: float = Field(..., description="Required data maximum value")


class FieldEntry(BaseModel):
    model_config = ConfigDict(extra="forbid")
    name: str = Field(..., description="Required field name")
    unit: str = Field(..., description="Required unit of measurement")
    info: str = Field(..., description="Required short description")
    ucd: str = Field(..., description="Required string of semicolon-separated UCDs")
    data_type: str = Field(
        ..., description="Required data type (e.g., int32, string, bool, float64)"
    )
    qc: Optional[QCEntry] = Field(
        None, description="Optional quality control parameters"
    )


class WavesMamlSchema(BaseModel):
    model_config = ConfigDict(extra="forbid")

    survey: SurveyName
    dataset: str
    table: str
    version: str | float
    date: date_aliased

    author: str = Field(..., description="Required lead author name and <email>")
    coauthors: Optional[List[str]] = Field(
        None, description="Optional list of coauthor names and <emails>"
    )

    DOIs: Optional[List[DOIEntry]] = None
    depends: Optional[List[DependEntry]] = None
    description: str
    comments: Optional[List[str]] = None
    license: Optional[License] = None
    keywords: Optional[List[str]] = None
    MAML_version: float
    fields: List[FieldEntry]

    # ---- validators ----

    @field_validator("author")
    @classmethod
    def validate_author(cls, value: str) -> str:
        return _validate_name_email(value)

    @field_validator("coauthors", mode="before")
    @classmethod
    def validate_coauthors(cls, value: list[str]):
        if value is None:
            return value
        if not isinstance(value, list):
            raise ValueError(f"Invalid coauthor '{value}'.")
        return [_validate_name_email(author) for author in value]

    @field_validator("MAML_version", mode="before")
    @classmethod
    def validate_MAML_version(cls, value: float):
        if value != MAML_VERSION:
            raise ValueError(f"Invalid MAML_version, value should be: {MAML_VERSION}.")
        return value
    
    